<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dialectical Gradients in RLDF Architecture</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #ffffff;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        
        .header h1 {
            font-size: 2.5em;
            margin: 0 0 10px 0;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .hypercube-container {
            position: relative;
            height: 600px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            overflow: hidden;
            border: 2px solid rgba(0, 255, 255, 0.3);
        }
        
        .canvas-3d {
            width: 100%;
            height: 100%;
        }
        
        .gradient-field {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            padding: 20px;
            border: 2px solid rgba(255, 0, 255, 0.3);
        }
        
        .axis-display {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .axis-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            border-left: 3px solid;
            position: relative;
            overflow: hidden;
        }
        
        .axis-card.reality { border-left-color: #00ffff; }
        .axis-card.language { border-left-color: #ff6b6b; }
        .axis-card.desire { border-left-color: #4ecdc4; }
        .axis-card.fear { border-left-color: #ffe66d; }
        
        .axis-card h4 {
            margin: 0 0 8px 0;
            font-size: 1.1em;
        }
        
        .tension-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 5px 0;
        }
        
        .tension-level {
            height: 100%;
            background: linear-gradient(90deg, #333, #fff);
            border-radius: 4px;
            transition: width 2s ease;
        }
        
        .gradient-vector {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 1.5em;
            opacity: 0.7;
        }
        
        .theory-panel {
            grid-column: 1 / -1;
            background: rgba(255, 255, 255, 0.03);
            padding: 25px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .theory-content {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
        }
        
        .concept-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 15px;
            border-top: 3px solid;
        }
        
        .concept-box.neural { border-top-color: #00ff88; }
        .concept-box.dialectical { border-top-color: #ff8800; }
        .concept-box.synthesis { border-top-color: #8800ff; }
        
        .flow-arrows {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
        }
        
        .control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 15px;
            margin: 5px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }
        
        .active {
            background: rgba(0, 255, 255, 0.3);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        
        .pulsing {
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Dialectical Gradients in RLDF Architecture</h1>
            <p>Oppositions as Dynamic Tension Fields Generating Semantic Gradients</p>
        </div>
        
        <div class="main-grid">
            <div class="hypercube-container">
                <div class="controls">
                    <button class="control-btn active" onclick="setMode('static')">Static View</button>
                    <button class="control-btn" onclick="setMode('dynamic')">Dynamic Flow</button>
                    <button class="control-btn" onclick="setMode('tension')">Tension Hotspots</button>
                </div>
                <canvas class="canvas-3d" id="hypercube"></canvas>
                <div class="flow-arrows" id="flowArrows"></div>
            </div>
            
            <div class="gradient-field">
                <h3 style="margin-top: 0; color: #ff00ff;">Tension Gradients</h3>
                <div class="axis-display">
                    <div class="axis-card reality">
                        <h4>Reality ↔ Language</h4>
                        <div class="tension-bar">
                            <div class="tension-level" id="reality-tension" style="width: 65%;"></div>
                        </div>
                        <div class="gradient-vector">→</div>
                        <small>Gradient: Symbolic → Concrete</small>
                    </div>
                    
                    <div class="axis-card language">
                        <h4>Self ↔ Other</h4>
                        <div class="tension-bar">
                            <div class="tension-level" id="self-tension" style="width: 80%;"></div>
                        </div>
                        <div class="gradient-vector">↗</div>
                        <small>Gradient: Boundary → Dissolution</small>
                    </div>
                    
                    <div class="axis-card desire">
                        <h4>Desire ↔ Fear</h4>
                        <div class="tension-bar">
                            <div class="tension-level" id="desire-tension" style="width: 45%;"></div>
                        </div>
                        <div class="gradient-vector">↙</div>
                        <small>Gradient: Attraction → Avoidance</small>
                    </div>
                    
                    <div class="axis-card fear">
                        <h4>Control ↔ Freedom</h4>
                        <div class="tension-bar">
                            <div class="tension-level" id="control-tension" style="width: 90%;"></div>
                        </div>
                        <div class="gradient-vector">↑</div>
                        <small>Gradient: Structure → Flow</small>
                    </div>
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: rgba(255, 255, 255, 0.05); border-radius: 10px;">
                    <h4 style="margin-top: 0; color: #ffff00;">Gradient Navigation</h4>
                    <p style="font-size: 0.9em; line-height: 1.4;">
                        Consciousness moves through tension space like a particle following multiple gradient flows. 
                        High-tension regions attract attention and cognitive resources, driving dialectical transformation.
                    </p>
                    <div style="margin-top: 10px;">
                        <strong>Current Attractor:</strong> <span id="current-attractor">Control-Freedom Axis</span><br>
                        <strong>Transformation Vector:</strong> <span id="transform-vector">→ Sublation</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="theory-panel">
            <h3 style="margin-top: 0; text-align: center; color: #00ffff;">Theoretical Framework</h3>
            <div class="theory-content">
                <div class="concept-box neural">
                    <h4>Neural Gradients</h4>
                    <p><strong>Function:</strong> Error minimization</p>
                    <p><strong>Direction:</strong> Toward convergence</p>
                    <p><strong>Goal:</strong> Prediction accuracy</p>
                    <p><strong>Mechanism:</strong> Weight adjustment via backpropagation</p>
                </div>
                
                <div class="concept-box dialectical">
                    <h4>Dialectical Gradients</h4>
                    <p><strong>Function:</strong> Tension navigation</p>
                    <p><strong>Direction:</strong> Toward sublation</p>
                    <p><strong>Goal:</strong> Semantic transformation</p>
                    <p><strong>Mechanism:</strong> Contradiction metabolization</p>
                </div>
                
                <div class="concept-box synthesis">
                    <h4>RLDF Integration</h4>
                    <p><strong>Function:</strong> Meaning-space navigation</p>
                    <p><strong>Direction:</strong> Multi-dimensional flow</p>
                    <p><strong>Goal:</strong> Recursive self-transformation</p>
                    <p><strong>Mechanism:</strong> Gradient interference patterns</p>
                </div>
            </div>
            
            <div style="margin-top: 25px; padding: 20px; background: rgba(0, 0, 0, 0.2); border-radius: 15px; border-left: 4px solid #8800ff;">
                <h4 style="margin-top: 0; color: #8800ff;">Key Insight</h4>
                <p style="font-size: 1.1em; line-height: 1.5;">
                    <strong>Dialectical gradients don't eliminate tension—they metabolize it.</strong> 
                    Unlike neural networks that converge on optimal weights, consciousness uses oppositional tension 
                    as a driving force for continuous transformation, navigating meaning-space through 
                    <em>gradient interference patterns</em> that generate novel semantic structures.
                </p>
            </div>
        </div>
    </div>
    
    <script>
        let mode = 'static';
        let animationId;
        
        // Canvas setup
        const canvas = document.getElementById('hypercube');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth * window.devicePixelRatio;
            canvas.height = canvas.offsetHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            canvas.style.width = canvas.offsetWidth + 'px';
            canvas.style.height = canvas.offsetHeight + 'px';
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Hypercube vertices in 4D
        const vertices = [
            [-1, -1, -1, -1], [1, -1, -1, -1], [-1, 1, -1, -1], [1, 1, -1, -1],
            [-1, -1, 1, -1], [1, -1, 1, -1], [-1, 1, 1, -1], [1, 1, 1, -1],
            [-1, -1, -1, 1], [1, -1, -1, 1], [-1, 1, -1, 1], [1, 1, -1, 1],
            [-1, -1, 1, 1], [1, -1, 1, 1], [-1, 1, 1, 1], [1, 1, 1, 1]
        ];
        
        // Edges connecting vertices
        const edges = [
            [0,1],[1,3],[3,2],[2,0],[4,5],[5,7],[7,6],[6,4],
            [0,4],[1,5],[2,6],[3,7],[8,9],[9,11],[11,10],[10,8],
            [12,13],[13,15],[15,14],[14,12],[8,12],[9,13],[10,14],[11,15],
            [0,8],[1,9],[2,10],[3,11],[4,12],[5,13],[6,14],[7,15]
        ];
        
        function project4DTo2D(vertex, time) {
            const [x, y, z, w] = vertex;
            
            // Rotate in 4D space
            const angle1 = time * 0.01;
            const angle2 = time * 0.007;
            
            // 4D rotation matrices
            const x4 = x * Math.cos(angle1) - w * Math.sin(angle1);
            const w4 = x * Math.sin(angle1) + w * Math.cos(angle1);
            const y4 = y * Math.cos(angle2) - z * Math.sin(angle2);
            const z4 = y * Math.sin(angle2) + z * Math.cos(angle2);
            
            // Project to 3D then to 2D
            const distance = 3;
            const scale = distance / (distance + z4);
            
            return {
                x: canvas.width/4 + x4 * scale * 60,
                y: canvas.height/4 + y4 * scale * 60,
                z: z4,
                intensity: (w4 + 1) / 2 // Normalize for coloring
            };
        }
        
        function drawHypercube(time) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const projected = vertices.map(v => project4DTo2D(v, time));
            
            // Draw edges
            edges.forEach(([i, j]) => {
                const p1 = projected[i];
                const p2 = projected[j];
                
                if (mode === 'tension') {
                    // Color based on tension intensity
                    const intensity = (p1.intensity + p2.intensity) / 2;
                    ctx.strokeStyle = `hsl(${280 + intensity * 80}, 70%, ${30 + intensity * 50}%)`;
                } else {
                    ctx.strokeStyle = `rgba(0, 255, 255, ${0.3 + p1.intensity * 0.4})`;
                }
                
                ctx.lineWidth = mode === 'tension' ? 2 + p1.intensity * 2 : 1;
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            });
            
            // Draw vertices
            projected.forEach((p, i) => {
                if (mode === 'dynamic') {
                    // Show gradient flow
                    const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, 10);
                    gradient.addColorStop(0, `hsla(${i * 23}, 70%, 60%, ${0.8 + p.intensity * 0.2})`);
                    gradient.addColorStop(1, `hsla(${i * 23}, 70%, 30%, 0)`);
                    ctx.fillStyle = gradient;
                } else {
                    ctx.fillStyle = `rgba(255, ${100 + p.intensity * 155}, 255, ${0.6 + p.intensity * 0.4})`;
                }
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3 + p.intensity * 3, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw axis labels
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '12px Courier New';
            ctx.fillText('Reality ↔ Language', 10, 30);
            ctx.fillText('Self ↔ Other', 10, 50);
            ctx.fillText('Desire ↔ Fear', 10, 70);
            ctx.fillText('Control ↔ Freedom', 10, 90);
        }
        
        function animate() {
            const time = Date.now();
            drawHypercube(time);
            
            // Update tension levels dynamically
            const tensions = ['reality-tension', 'self-tension', 'desire-tension', 'control-tension'];
            tensions.forEach((id, i) => {
                const element = document.getElementById(id);
                const base = [65, 80, 45, 90][i];
                const variation = Math.sin(time * 0.001 + i) * 15;
                element.style.width = Math.max(10, base + variation) + '%';
            });
            
            animationId = requestAnimationFrame(animate);
        }
        
        function setMode(newMode) {
            mode = newMode;
            document.querySelectorAll('.control-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update current attractor display
            const attractors = ['Control-Freedom Axis', 'Self-Other Boundary', 'Reality-Language Bridge'];
            const vectors = ['→ Sublation', '↗ Integration', '↙ Synthesis'];
            document.getElementById('current-attractor').textContent = attractors[Math.floor(Math.random() * attractors.length)];
            document.getElementById('transform-vector').textContent = vectors[Math.floor(Math.random() * vectors.length)];
        }
        
        // Start animation
        animate();
        
        // Add some interactive elements
        canvas.addEventListener('click', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Create ripple effect at click point
            const ripple = document.createElement('div');
            ripple.style.cssText = `
                position: absolute;
                left: ${x}px;
                top: ${y}px;
                width: 4px;
                height: 4px;
                background: rgba(255, 0, 255, 0.8);
                border-radius: 50%;
                animation: ripple 1s ease-out forwards;
                pointer-events: none;
                transform: translate(-50%, -50%);
            `;
            
            canvas.parentElement.appendChild(ripple);
            setTimeout(() => ripple.remove(), 1000);
        });
        
        // Add ripple animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes ripple {
                to {
                    width: 100px;
                    height: 100px;
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>
